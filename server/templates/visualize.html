<!DOCTYPE html>
<html>
<head>
    <title>3D Blueprint Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: #ffffff;
        }
        canvas { display: block; }
        #error-message {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 300px;
        }
        #floor-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #floor-controls button {
            margin: 0 5px;
            padding: 5px 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #floor-controls button.active {
            background: #0078d4;
        }
        #floor-controls button:hover {
            background: #555;
        }
        #object-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }
        .controls-label {
            font-weight: bold;
            margin-right: 10px;
        }
        #unit-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            z-index: 100;
            cursor: pointer;
            border: 1px solid #555;
            display: flex;
            align-items: center;
        }
        #unit-toggle:hover {
            background: rgba(50, 50, 50, 0.8);
        }
        #unit-toggle-icon {
            margin-right: 5px;
        }
        #display-settings {
            position: absolute;
            top: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        .setting-toggle {
            margin: 5px 0;
        }
        .setting-toggle label {
            cursor: pointer;
            margin-left: 5px;
        }
        #floor-navigation {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #floor-navigation button {
            padding: 5px 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 18px;
            width: 40px;
        }
        #floor-navigation button:hover {
            background: #555;
        }
        #current-floor-display {
            font-weight: bold;
            padding: 0 10px;
        }
    </style>
</head>
<body>
    <div id="blueprint-container"></div>
    <div id="error-message"></div>
    <div id="info-panel">
        <h3>Blueprint Info</h3>
        <div id="blueprint-stats"></div>
    </div>
    <div id="floor-controls">
        <span class="controls-label">Floor:</span>
        <!-- Floor buttons will be generated here -->
    </div>
    <div id="floor-navigation">
        <button id="floor-up">‚ñ≤</button>
        <span id="current-floor-display">Floor 0</span>
        <button id="floor-down">‚ñº</button>
    </div>
    <div id="object-info"></div>
    <div id="unit-toggle">
        <span id="unit-toggle-icon">üìè</span>
        <span id="current-unit">Metric (m)</span>
    </div>
    <div id="display-settings">
        <div class="setting-toggle">
            <input type="checkbox" id="show-labels" checked>
            <label for="show-labels">Show Room Labels</label>
        </div>
        <div class="setting-toggle">
            <input type="checkbox" id="show-floor-plans" checked>
            <label for="show-floor-plans">Show Floor Plans</label>
        </div>
    </div>

    <script>
        // Blueprint data from server
        let blueprintData;
        try {
            blueprintData = JSON.parse('{{ blueprint|tojson|safe }}');
            console.log("Loaded blueprint data:", blueprintData);
        } catch (e) {
            showError("Failed to parse blueprint data: " + e.message);
            console.error("Blueprint data parsing error:", e);
        }

        let currentFloor = 0;
        const meshes = {
            rooms: [],
            walls: [],
            objects: [],
            labels: []
        };
        let selectedObject = null;
        let unitSystem = 'metric'; // Default unit system
        let showLabels = true;
        let showFloorPlans = true;
        let availableFloors = []; // Track available floors

        // Unit conversion constants
        const METERS_TO_FEET = 3.28084;
        const SQUARE_METERS_TO_SQUARE_FEET = 10.7639;

        // Unit conversion utility functions
        function metersToFeet(meters) {
            return meters * METERS_TO_FEET;
        }

        function squareMetersToSquareFeet(squareMeters) {
            return squareMeters * SQUARE_METERS_TO_SQUARE_FEET;
        }

        function formatDistance(meters) {
            if (unitSystem === 'metric') {
                return `${meters.toFixed(2)} m`;
            } else {
                const feet = metersToFeet(meters);
                if (feet < 1) {
                    return `${(feet * 12).toFixed(1)} in`;
                }
                const wholeFeet = Math.floor(feet);
                const inches = Math.round((feet - wholeFeet) * 12);
                if (inches === 0) {
                    return `${wholeFeet} ft`;
                } else {
                    return `${wholeFeet}' ${inches}"`;
                }
            }
        }

        function formatArea(squareMeters) {
            if (unitSystem === 'metric') {
                return `${squareMeters.toFixed(2)} m¬≤`;
            } else {
                const squareFeet = squareMetersToSquareFeet(squareMeters);
                return `${squareFeet.toFixed(2)} ft¬≤`;
            }
        }

        // Standard material colors
        const COLORS = {
            ROOM: 0x9bc4e2,
            WALL: 0x8B8B8B,
            FLOOR: 0xcccccc,
            CEILING: 0xe0e0e0,
            SELECTED: 0xffcc00,
            LABEL_BG: 0x000000,
            LABEL_TEXT: 0xffffff,
            OBJECT: {
                'sofa': 0x7b68ee,
                'coffee_table': 0x8b4513,
                'tv_unit': 0x2f4f4f,
                'tv_stand': 0x2f4f4f,
                'armchair': 0x6a5acd,
                'refrigerator': 0xb0c4de,
                'stove': 0x696969,
                'sink': 0xb0e0e6,
                'counter': 0xa9a9a9,
                'dining_table': 0x8b4513,
                'chair': 0xa0522d,
                'bed': 0x6495ed,
                'king_bed': 0x4169e1,
                'wardrobe': 0xdaa520,
                'nightstand': 0xd2b48c,
                'toilet': 0xf0f8ff,
                'shower': 0x87ceeb,
                'bathtub': 0xb0e0e6,
                'desk': 0x8b4513,
                'office_chair': 0x2f4f4f,
                'bookshelf': 0xdeb887,
                'default': 0x9370db
            }
        };

        // Debug floor information
        console.debug("Analyzing floor data in rooms:");
        if (blueprintData && blueprintData.rooms && blueprintData.rooms.length > 0) {
            const floorValues = {};

            // Log floor values for each room
            blueprintData.rooms.forEach((room, index) => {
                let floorVal = room.floor !== undefined ? room.floor :
                              (room.floor_level !== undefined ? room.floor_level : 'undefined');
                console.debug(`Room "${room.name || 'Unnamed'}" (ID: ${room.id || index}): floor = ${floorVal}`);

                // Count occurrences of each floor value
                if (floorVal !== 'undefined') {
                    floorVal = Number(floorVal);
                    floorValues[floorVal] = (floorValues[floorVal] || 0) + 1;
                }
            });

            console.debug("Floor distribution:", floorValues);
        }

        // Extract available floors from rooms
        if (blueprintData && blueprintData.rooms && blueprintData.rooms.length > 0) {
            // First, check if we have explicit floors array
            if (blueprintData.floors && blueprintData.floors.length > 0) {
                availableFloors = [...new Set(blueprintData.floors.map(floor => floor.level))].sort((a, b) => a - b);
            }
            // If not, extract floor information from rooms
            else {
                // Extract all floor values from rooms, defaulting to 0 if not specified
                const floorValues = blueprintData.rooms.map(room => {
                    // Handle different formats - check if floor is specified or try to extract from name
                    if (room.floor !== undefined) {
                        return Number(room.floor); // Convert to number to ensure proper comparison
                    }

                    // Try to extract floor number from name if possible
                    if (room.name) {
                        const lowerName = room.name.toLowerCase();
                        if (lowerName.includes('floor')) {
                            const matches = lowerName.match(/floor\s*(\d+)/i);
                            if (matches && matches[1]) {
                                return Number(matches[1]);
                            }
                        }
                        // Check for basement, ground floor, etc.
                        if (lowerName.includes('basement')) return -1;
                        if (lowerName.includes('ground')) return 0;
                        if (lowerName.includes('first')) return 1;
                        if (lowerName.includes('second')) return 2;
                    }

                    // If no floor specified, use custom properties or just default to 0
                    return room.floor_level !== undefined ? Number(room.floor_level) : 0;
                });

                // Get unique floor values and sort
                availableFloors = [...new Set(floorValues)].sort((a, b) => a - b);
            }

            console.log("Detected floors:", availableFloors);

            // If no floors were detected, create at least one floor (0)
            if (availableFloors.length === 0) {
                availableFloors = [0];
                console.log("No floors detected, defaulting to floor 0");
            }

            // Count rooms per floor to find a floor with content
            const roomsPerFloor = {};
            blueprintData.rooms.forEach(room => {
                const floorNum = room.floor !== undefined ? Number(room.floor) : 0;
                roomsPerFloor[floorNum] = (roomsPerFloor[floorNum] || 0) + 1;
            });

            console.log("Rooms per floor:", roomsPerFloor);

            // Set initial current floor prioritizing floors with content
            // First try Ground Floor (0) if it has rooms
            if (roomsPerFloor[0] && roomsPerFloor[0] > 0 && availableFloors.includes(0)) {
                currentFloor = 0;
                console.log("Setting initial floor to Ground Floor (0) - has content");
            }
            // Then try 1st Floor if it has rooms
            else if (roomsPerFloor[1] && roomsPerFloor[1] > 0 && availableFloors.includes(1)) {
                currentFloor = 1;
                console.log("Setting initial floor to 1st Floor (1) - has content");
            }
            // Then try any other floor with content starting from the lowest positive floor
            else {
                const floorsWithContent = Object.keys(roomsPerFloor)
                    .filter(floor => roomsPerFloor[floor] > 0)
                    .map(Number)
                    .sort((a, b) => a - b);

                if (floorsWithContent.length > 0) {
                    // Prefer positive floors first
                    const positiveFloors = floorsWithContent.filter(f => f >= 0);
                    if (positiveFloors.length > 0) {
                        currentFloor = positiveFloors[0];
                        console.log(`Setting initial floor to ${currentFloor} - has content`);
                    } else {
                        currentFloor = floorsWithContent[0];
                        console.log(`Setting initial floor to ${currentFloor} - has content (negative floor)`);
                    }
                }
                // If no floor has content or we couldn't determine, use first available floor
                else {
                    currentFloor = availableFloors[0];
                    console.log(`Setting initial floor to ${currentFloor} - no floor has content`);
                }
            }
        } else {
            // Default if no rooms
            availableFloors = [0];
            currentFloor = 0;
            console.warn("No rooms found in blueprint data");
        }

        // Update info panel
        const statsDiv = document.getElementById('blueprint-stats');
        statsDiv.innerHTML = `
            <p>Rooms: ${blueprintData.rooms ? blueprintData.rooms.length : 0}</p>
            <p>Walls: ${blueprintData.walls ? blueprintData.walls.length : 0}</p>
            <p>Objects: ${blueprintData.objects ? blueprintData.objects.length : 0}</p>
            <p>Floors: ${availableFloors.length}</p>
            <p><em>Click on objects for more info</em></p>
        `;

        // Set up floor controls
        setupFloorControls();
        updateFloorDisplay();

        // Set up Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x121212); // Dark background

        // Camera
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('blueprint-container').appendChild(renderer.domElement);

        // Controls for camera
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.minDistance = 5;
        controls.maxDistance = 50;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

        // Add another light from the opposite direction
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(-10, 15, -10);
        scene.add(directionalLight2);

        // Grid helper
        const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x333333);
        gridHelper.position.y = -0.01; // Slightly below everything else
        scene.add(gridHelper);

        // Raycaster for object selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Set up unit toggle
        document.getElementById('unit-toggle').addEventListener('click', function() {
            unitSystem = unitSystem === 'metric' ? 'imperial' : 'metric';
            document.getElementById('current-unit').textContent =
                unitSystem === 'metric' ? 'Metric (m)' : 'Imperial (ft)';

            // Update any displayed information
            if (selectedObject) {
                showObjectInfo(selectedObject);
            }
        });

        // Setup display settings toggles
        document.getElementById('show-labels').addEventListener('change', function() {
            showLabels = this.checked;
            updateRoomLabels();
        });

        document.getElementById('show-floor-plans').addEventListener('change', function() {
            showFloorPlans = this.checked;
            renderBlueprint();
        });

        // Set up floor navigation controls
        document.getElementById('floor-up').addEventListener('click', function() {
            changeFloor(1);
        });

        document.getElementById('floor-down').addEventListener('click', function() {
            changeFloor(-1);
        });

        // Main rendering function
        renderBlueprint();

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize(){
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Mouse event handlers for object selection
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('mousedown', onDocumentMouseDown, false);

        function onDocumentMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(meshes.objects.concat(meshes.rooms));

            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'default';
            }
        }

        function onDocumentMouseDown(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(meshes.objects.concat(meshes.rooms));

            if (intersects.length > 0) {
                const selectedMesh = intersects[0].object;

                // Reset previous selection
                if (selectedObject) {
                    selectedObject.material.emissive.setHex(0x000000);
                }

                // Highlight selected object
                selectedObject = selectedMesh;
                selectedObject.material.emissive.setHex(0x333333);

                // Show object info
                showObjectInfo(selectedObject);
            } else {
                // Hide object info when clicking outside
                hideObjectInfo();

                // Reset previous selection
                if (selectedObject) {
                    selectedObject.material.emissive.setHex(0x000000);
                    selectedObject = null;
                }
            }
        }

        // Setup floor control buttons
        function setupFloorControls() {
            const floorControls = document.getElementById('floor-controls');

            // Clear existing buttons
            while (floorControls.childNodes.length > 1) {
                floorControls.removeChild(floorControls.lastChild);
            }

            // If no floor data is explicitly available, try to derive from rooms
            if (!availableFloors || availableFloors.length === 0) {
                document.getElementById('floor-controls').style.display = 'none';
                document.getElementById('floor-navigation').style.display = 'none';
                return;
            }

            // Add "All Floors" button
            const allFloorsBtn = document.createElement('button');
            allFloorsBtn.textContent = 'All Floors';
            allFloorsBtn.className = currentFloor === 'all' ? 'active' : '';
            allFloorsBtn.onclick = () => {
                setCurrentFloor('all');
                setActiveButton(allFloorsBtn);
            };
            floorControls.appendChild(allFloorsBtn);

            // Add individual floor buttons
            availableFloors.forEach(floorNum => {
                const btn = document.createElement('button');
                btn.textContent = getFloorName(floorNum);
                btn.dataset.floor = floorNum; // Store floor number as data attribute
                btn.className = currentFloor === floorNum ? 'active' : '';
                btn.onclick = () => {
                    setCurrentFloor(Number(floorNum)); // Convert to number to ensure type consistency
                    setActiveButton(btn);
                };
                floorControls.appendChild(btn);
            });
        }

        function getFloorName(floorNum) {
            if (floorNum === 0) return 'Ground';
            if (floorNum === 1) return '1st';
            if (floorNum === 2) return '2nd';
            if (floorNum === 3) return '3rd';
            if (floorNum > 3) return `${floorNum}th`;
            if (floorNum === -1) return 'Basement';
            if (floorNum < -1) return `B${Math.abs(floorNum)}`;
            return `Floor ${floorNum}`;
        }

        function setActiveButton(activeBtn) {
            const buttons = document.querySelectorAll('#floor-controls button');
            buttons.forEach(btn => {
                btn.className = (btn === activeBtn) ? 'active' : '';
            });
        }

        function changeFloor(direction) {
            if (availableFloors.length === 0) return;

            // Handle 'all' case
            if (currentFloor === 'all') {
                // When going from 'all' to a specific floor, choose either first or last floor based on direction
                currentFloor = direction > 0 ? availableFloors[0] : availableFloors[availableFloors.length - 1];
                setCurrentFloor(currentFloor);
                return;
            }

            // Find current index
            const currentIndex = availableFloors.indexOf(Number(currentFloor));
            if (currentIndex === -1) {
                // If current floor not found, default to first floor
                setCurrentFloor(availableFloors[0]);
                return;
            }

            // Calculate new index with bounds check
            let newIndex = currentIndex + direction;
            if (newIndex < 0) newIndex = 0;
            if (newIndex >= availableFloors.length) newIndex = availableFloors.length - 1;

            // Set new floor
            setCurrentFloor(availableFloors[newIndex]);
        }

        function setCurrentFloor(floor) {
            currentFloor = floor;
            updateFloorDisplay();
            renderBlueprint();

            // Also update the active button in the floor controls
            const buttons = document.querySelectorAll('#floor-controls button');
            buttons.forEach(btn => {
                if (floor === 'all' && btn.textContent === 'All Floors') {
                    btn.className = 'active';
                } else if (btn.dataset.floor !== undefined && Number(btn.dataset.floor) === Number(floor)) {
                    btn.className = 'active';
                } else {
                    btn.className = '';
                }
            });
        }

        function updateFloorDisplay() {
            const floorDisplay = document.getElementById('current-floor-display');
            if (floorDisplay) {
                if (currentFloor === 'all') {
                    floorDisplay.textContent = 'All Floors';
                } else {
                    floorDisplay.textContent = getFloorName(currentFloor);
                }
            }
        }

        // Helper function to get material for rooms
        function getRoomMaterial(roomData) {
            return new THREE.MeshPhongMaterial({
                color: COLORS.ROOM,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
        }

        // Helper function to get material for walls
        function getWallMaterial() {
            return new THREE.MeshPhongMaterial({
                color: COLORS.WALL,
                transparent: false,
                opacity: 1.0,
                side: THREE.DoubleSide
            });
        }

        // Helper function to get material for objects
        function getObjectMaterial(objectType) {
            const color = COLORS.OBJECT[objectType] || COLORS.OBJECT.default;
            return new THREE.MeshPhongMaterial({
                color: color,
                transparent: false,
                opacity: 1.0,
                side: THREE.DoubleSide
            });
        }

        // Clear all rendered elements
        function clearScene() {
            // Clear rooms
            meshes.rooms.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            meshes.rooms = [];

            // Clear walls
            meshes.walls.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            meshes.walls = [];

            // Clear objects
            meshes.objects.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            meshes.objects = [];

            // Clear labels
            meshes.labels.forEach(label => {
                scene.remove(label);
            });
            meshes.labels = [];
        }

        // Create a text label sprite
        function createTextLabel(text, x, y, z, userData) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;

            // Draw background
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Draw text
            context.font = 'Bold 24px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width/2, canvas.height/2);

            // Create sprite texture
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });

            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(4, 2, 1);
            sprite.userData = userData;

            scene.add(sprite);
            meshes.labels.push(sprite);

            return sprite;
        }

        // Render rooms based on their geometry
        function renderRooms(rooms) {
            if (!rooms || !rooms.length) return;

            rooms.forEach(room => {
                try {
                    if (!room.shape || !room.shape.points || room.shape.points.length < 3) {
                        console.warn(`Room ${room.name || 'unnamed'} has invalid geometry`);
                        return;
                    }

                    // Create room shape
                    const shape = new THREE.Shape();
                    const points = room.shape.points;

                    // Start at the first point
                    shape.moveTo(points[0].x, points[0].y);

                    // Add lines to all other points
                    for (let i = 1; i < points.length; i++) {
                        shape.lineTo(points[i].x, points[i].y);
                    }

                    // Close the shape
                    shape.lineTo(points[0].x, points[0].y);

                    // Create extruded geometry for walls
                    const height = room.dimensions?.height || 2.5; // Default 2.5m ceiling height
                    const extrudeSettings = {
                        steps: 1,
                        depth: height,
                        bevelEnabled: false
                    };

                    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                    geometry.rotateX(-Math.PI / 2); // Rotate to be vertical
                    geometry.translate(0, 0, 0); // Position at floor level

                    // Create room mesh
                    const material = getRoomMaterial(room);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = room; // Attach room data to the mesh for interaction

                    // Calculate floor offset based on current floor
                    const floorOffset = room.floor ? Number(room.floor) * 3.5 : 0; // 3.5m per floor
                    mesh.position.y = floorOffset;

                    scene.add(mesh);
                    meshes.rooms.push(mesh);
                } catch (e) {
                    console.error(`Error rendering room ${room.name || 'unnamed'}:`, e);
                }
            });
        }

        // Render walls based on wall data
        function renderWalls(walls) {
            if (!walls || !walls.length) return;

            walls.forEach(wall => {
                try {
                    if (!wall.start || !wall.end) {
                        console.warn('Wall has invalid geometry', wall);
                        return;
                    }

                    // Create wall geometry
                    const start = wall.start;
                    const end = wall.end;

                    // Calculate wall dimensions
                    const length = Math.sqrt(
                        Math.pow(end.x - start.x, 2) +
                        Math.pow(end.z - start.z, 2)
                    );

                    const height = wall.height || 2.5;  // Default 2.5m wall height
                    const thickness = wall.thickness || 0.15;  // Default 15cm thickness

                    // Create box geometry
                    const geometry = new THREE.BoxGeometry(length, height, thickness);

                    // Calculate wall angle and position
                    const angle = Math.atan2(end.z - start.z, end.x - start.x);
                    const centerX = (start.x + end.x) / 2;
                    const centerZ = (start.z + end.z) / 2;

                    // Create wall mesh
                    const material = getWallMaterial();
                    const mesh = new THREE.Mesh(geometry, material);

                    // Position and rotate wall
                    mesh.position.set(centerX, height / 2, centerZ);
                    mesh.rotation.y = angle;
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = wall;

                    // Calculate floor offset based on current floor
                    const floorOffset = wall.floor ? Number(wall.floor) * 3.5 : 0; // 3.5m per floor
                    mesh.position.y += floorOffset;

                    scene.add(mesh);
                    meshes.walls.push(mesh);
                } catch (e) {
                    console.error('Error rendering wall:', e);
                }
            });
        }

        // Render furniture and other objects
        function renderObjects(objects) {
            if (!objects || !objects.length) return;

            objects.forEach(object => {
                try {
                    if (!object.position) {
                        console.warn('Object has invalid position', object);
                        return;
                    }

                    // Get object dimensions (defaults if not specified)
                    const width = object.dimensions?.width || 1.0;
                    const height = object.dimensions?.height || 0.5;
                    const depth = object.dimensions?.depth || 1.0;

                    // Create object geometry based on type
                    let geometry;

                    switch (object.type?.toLowerCase()) {
                        case 'sofa':
                        case 'bed':
                        case 'table':
                            // Rounded box for furniture
                            geometry = new THREE.BoxGeometry(width, height, depth);
                            break;
                        case 'chair':
                        case 'stool':
                            // Small cube for chairs
                            geometry = new THREE.BoxGeometry(width, height, depth);
                            break;
                        case 'lamp':
                        case 'light':
                            // Sphere for lamps
                            geometry = new THREE.SphereGeometry(width / 2, 16, 16);
                            break;
                        default:
                            // Default to box
                            geometry = new THREE.BoxGeometry(width, height, depth);
                    }

                    // Create object mesh
                    const material = getObjectMaterial(object.type);
                    const mesh = new THREE.Mesh(geometry, material);

                    // Position object
                    mesh.position.set(
                        object.position.x,
                        (height / 2) + (object.position.y || 0),
                        object.position.z
                    );

                    // Apply rotation if specified
                    if (object.rotation) {
                        mesh.rotation.y = object.rotation.y || 0;
                    }

                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = object;

                    // Calculate floor offset based on room's floor
                    if (object.room_id && blueprintData.rooms) {
                        const room = blueprintData.rooms.find(r => r.id === object.room_id);
                        if (room && room.floor !== undefined) {
                            const floorOffset = Number(room.floor) * 3.5; // 3.5m per floor
                            mesh.position.y += floorOffset;
                        }
                    }

                    scene.add(mesh);
                    meshes.objects.push(mesh);
                } catch (e) {
                    console.error(`Error rendering object ${object.name || object.type || 'unnamed'}:`, e);
                }
            });
        }

        // Create and add room labels
        function addRoomLabels(rooms) {
            // Remove previous labels
            meshes.labels.forEach(label => {
                scene.remove(label);
            });
            meshes.labels = [];

            // Skip if labels are disabled
            if (!showLabels) return;

            rooms.forEach(room => {
                if (!room.name || !room.center) return;

                // Get room center
                const center = room.center;

                // Create text sprite for the label
                const labelHeight = room.dimensions?.height || 2.5;
                const floorOffset = room.floor ? Number(room.floor) * 3.5 : 0; // 3.5m per floor
                createTextLabel(room.name, center.x, labelHeight + 0.3 + floorOffset, center.z, room);
            });
        }

        // Update visibility of room labels
        function updateRoomLabels() {
            // Show/hide existing labels
            meshes.labels.forEach(label => {
                label.visible = showLabels;
            });

            // If labels are now visible but none exist, add them
            if (showLabels && meshes.labels.length === 0) {
                const roomsToRender = blueprintData.rooms.filter(room => {
                    if (currentFloor === 'all') return true;
                    return Number(room.floor) === Number(currentFloor);
                });
                addRoomLabels(roomsToRender);
            }
        }

        // Show object information panel
        function showObjectInfo(object) {
            const infoPanel = document.getElementById('object-info');
            if (!infoPanel || !object || !object.userData) return;

            const data = object.userData;
            let html = '';

            if (data.type) {
                html += `<h3>${capitalizeFirstLetter(data.type)}</h3>`;
            }

            if (data.name) {
                html += `<p><strong>Name:</strong> ${data.name}</p>`;
            }

            if (data.dimensions) {
                const dims = data.dimensions;
                if (unitSystem === 'metric') {
                    html += `<p><strong>Dimensions:</strong><br>`;
                    if (dims.width) html += `Width: ${dims.width.toFixed(2)} m<br>`;
                    if (dims.length || dims.depth) html += `Length: ${(dims.length || dims.depth).toFixed(2)} m<br>`;
                    if (dims.height) html += `Height: ${dims.height.toFixed(2)} m<br>`;
                    if (dims.area) html += `Area: ${dims.area.toFixed(2)} m¬≤`;
                    html += `</p>`;
                } else {
                    html += `<p><strong>Dimensions:</strong><br>`;
                    if (dims.width) {
                        const feet = metersToFeet(dims.width);
                        html += `Width: ${formatDistance(dims.width)}<br>`;
                    }
                    if (dims.length || dims.depth) {
                        const length = dims.length || dims.depth;
                        html += `Length: ${formatDistance(length)}<br>`;
                    }
                    if (dims.height) {
                        html += `Height: ${formatDistance(dims.height)}<br>`;
                    }
                    if (dims.area) {
                        html += `Area: ${formatArea(dims.area)}`;
                    }
                    html += `</p>`;
                }
            }

            // Show room info if it's a room
            if (data.room_type || data.room_category) {
                html += `<p><strong>Room Type:</strong> ${data.room_type || data.room_category}</p>`;
            }

            // If no data could be found, display a simple message
            if (html === '') {
                html = '<p>No additional information available</p>';
            }

            infoPanel.innerHTML = html;
            infoPanel.style.display = 'block';
        }

        // Hide object information panel
        function hideObjectInfo() {
            const infoPanel = document.getElementById('object-info');
            if (infoPanel) {
                infoPanel.style.display = 'none';
            }
        }

        // Helper function to capitalize first letter
        function capitalizeFirstLetter(string) {
            if (!string) return '';
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        // Display error message
        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';

                // Hide after 5 seconds
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Main render loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Start animation loop
        animate();

        // Render the entire blueprint based on current floor selection
        function renderBlueprint() {
            clearScene();

            if (!blueprintData || !blueprintData.rooms || blueprintData.rooms.length === 0) {
                console.warn("No blueprint data to render");
                return;
            }

            // Filter rooms by current floor if specified
            const roomsToRender = blueprintData.rooms.filter(room => {
                if (currentFloor === 'all') return true;
                // Convert both to numbers for comparison to avoid type mismatches
                return Number(room.floor) === Number(currentFloor);
            });

            // Render rooms
            renderRooms(roomsToRender);

            // Render walls for those rooms
            if (blueprintData.walls) {
                // For "all floors" view or specific floor view, show walls appropriately
                const wallsToRender = currentFloor === 'all' ?
                    blueprintData.walls :
                    blueprintData.walls.filter(wall => {
                        if (wall.floor !== undefined) {
                            return Number(wall.floor) === Number(currentFloor);
                        }
                        // For walls without floor info, try to match them to rooms on the current floor
                        // This is a heuristic approach
                        return true;
                    });

                renderWalls(wallsToRender);
            }

            // Render objects (furniture) for those rooms
            if (blueprintData.objects) {
                const objectsToRender = currentFloor === 'all' ?
                    blueprintData.objects :
                    blueprintData.objects.filter(obj => {
                        // Find the room for this object
                        const room = blueprintData.rooms.find(room => room.id === obj.room_id);
                        return room && Number(room.floor) === Number(currentFloor);
                    });

                renderObjects(objectsToRender);
            }

            // Add room labels
            if (showLabels) {
                addRoomLabels(roomsToRender);
            }
        }
    </script>
</body>
</html>