<!DOCTYPE html>
<html>
<head>
    <title>3D Blueprint Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: #ffffff;
        }
        canvas { display: block; }
        #error-message {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 300px;
        }
        #floor-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #floor-controls button {
            margin: 0 5px;
            padding: 5px 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #floor-controls button.active {
            background: #0078d4;
        }
        #floor-controls button:hover {
            background: #555;
        }
        #object-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }
        .controls-label {
            font-weight: bold;
            margin-right: 10px;
        }
        #unit-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            z-index: 100;
            cursor: pointer;
            border: 1px solid #555;
            display: flex;
            align-items: center;
        }
        #unit-toggle:hover {
            background: rgba(50, 50, 50, 0.8);
        }
        #unit-toggle-icon {
            margin-right: 5px;
        }
        #display-settings {
            position: absolute;
            top: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        .setting-toggle {
            margin: 5px 0;
        }
        .setting-toggle label {
            cursor: pointer;
            margin-left: 5px;
        }
        #floor-navigation {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #floor-navigation button {
            padding: 5px 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 18px;
            width: 40px;
        }
        #floor-navigation button:hover {
            background: #555;
        }
        #current-floor-display {
            font-weight: bold;
            padding: 0 10px;
        }
    </style>
</head>
<body>
    <div id="blueprint-container"></div>
    <div id="error-message"></div>
    <div id="info-panel">
        <h3>Blueprint Info</h3>
        <div id="blueprint-stats"></div>
    </div>
    <div id="floor-controls">
        <span class="controls-label">Floor:</span>
        <!-- Floor buttons will be generated here -->
    </div>
    <div id="floor-navigation">
        <button id="floor-up">‚ñ≤</button>
        <span id="current-floor-display">Floor 0</span>
        <button id="floor-down">‚ñº</button>
    </div>
    <div id="object-info"></div>
    <div id="unit-toggle">
        <span id="unit-toggle-icon">üìè</span>
        <span id="current-unit">Metric (m)</span>
    </div>
    <div id="display-settings">
        <div class="setting-toggle">
            <input type="checkbox" id="show-labels" checked>
            <label for="show-labels">Show Room Labels</label>
        </div>
        <div class="setting-toggle">
            <input type="checkbox" id="show-floor-plans" checked>
            <label for="show-floor-plans">Show Floor Plans</label>
        </div>
    </div>

    <script>
        // Blueprint data from server
        let blueprintData;
        let currentFloor = 0;
        const meshes = {
            rooms: [],
            walls: [],
            objects: [],
            labels: []
        };
        let selectedObject = null;
        let unitSystem = 'metric'; // Default unit system
        let showLabels = true;
        let showFloorPlans = true;
        let availableFloors = []; // Track available floors

        // Unit conversion constants
        const METERS_TO_FEET = 3.28084;
        const SQUARE_METERS_TO_SQUARE_FEET = 10.7639;

        // Unit conversion utility functions
        function metersToFeet(meters) {
            return meters * METERS_TO_FEET;
        }

        function squareMetersToSquareFeet(squareMeters) {
            return squareMeters * SQUARE_METERS_TO_SQUARE_FEET;
        }

        function formatDistance(meters) {
            if (unitSystem === 'metric') {
                return `${meters.toFixed(2)} m`;
            } else {
                const feet = metersToFeet(meters);
                if (feet < 1) {
                    return `${(feet * 12).toFixed(1)} in`;
                }
                const wholeFeet = Math.floor(feet);
                const inches = Math.round((feet - wholeFeet) * 12);
                if (inches === 0) {
                    return `${wholeFeet} ft`;
                } else {
                    return `${wholeFeet}' ${inches}"`;
                }
            }
        }

        function formatArea(squareMeters) {
            if (unitSystem === 'metric') {
                return `${squareMeters.toFixed(2)} m¬≤`;
            } else {
                const squareFeet = squareMetersToSquareFeet(squareMeters);
                return `${squareFeet.toFixed(2)} ft¬≤`;
            }
        }

        // Standard material colors
        const COLORS = {
            ROOM: 0x9bc4e2,
            WALL: 0x8B8B8B,
            FLOOR: 0xcccccc,
            CEILING: 0xe0e0e0,
            SELECTED: 0xffcc00,
            LABEL_BG: 0x000000,
            LABEL_TEXT: 0xffffff,
            OBJECT: {
                'sofa': 0x7b68ee,
                'coffee_table': 0x8b4513,
                'tv_unit': 0x2f4f4f,
                'tv_stand': 0x2f4f4f,
                'armchair': 0x6a5acd,
                'refrigerator': 0xb0c4de,
                'stove': 0x696969,
                'sink': 0xb0e0e6,
                'counter': 0xa9a9a9,
                'dining_table': 0x8b4513,
                'chair': 0xa0522d,
                'bed': 0x6495ed,
                'king_bed': 0x4169e1,
                'wardrobe': 0xdaa520,
                'nightstand': 0xd2b48c,
                'toilet': 0xf0f8ff,
                'shower': 0x87ceeb,
                'bathtub': 0xb0e0e6,
                'desk': 0x8b4513,
                'office_chair': 0x2f4f4f,
                'bookshelf': 0xdeb887,
                'default': 0x9370db
            }
        };

        try {
            blueprintData = JSON.parse('{{ blueprint|tojson|safe }}');
            console.log("Loaded blueprint data:", blueprintData);

            // Extract all available floors from rooms
            if (blueprintData && blueprintData.rooms) {
                availableFloors = [...new Set(blueprintData.rooms.map(room => room.floor !== undefined ? Number(room.floor) : 0))].sort((a, b) => a - b);
                console.log("Available floors:", availableFloors);
            }

            // Update info panel
            const statsDiv = document.getElementById('blueprint-stats');
            statsDiv.innerHTML = `
                <p>Rooms: ${blueprintData.rooms.length}</p>
                <p>Walls: ${blueprintData.walls ? blueprintData.walls.length : 0}</p>
                <p>Objects: ${blueprintData.objects ? blueprintData.objects.length : 0}</p>
                <p>Floors: ${availableFloors.length}</p>
                <p><em>Click on objects for more info</em></p>
            `;

            // Set up floor controls
            setupFloorControls();
            updateFloorDisplay();
        } catch (e) {
            showError("Failed to parse blueprint data: " + e.message);
        }

        // Set up Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x121212); // Dark background

        // Camera
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('blueprint-container').appendChild(renderer.domElement);

        // Controls for camera
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.minDistance = 5;
        controls.maxDistance = 50;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

        // Add another light from the opposite direction
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(-10, 15, -10);
        scene.add(directionalLight2);

        // Grid helper
        const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x333333);
        gridHelper.position.y = -0.01; // Slightly below everything else
        scene.add(gridHelper);

        // Raycaster for object selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Set up unit toggle
        document.getElementById('unit-toggle').addEventListener('click', function() {
            unitSystem = unitSystem === 'metric' ? 'imperial' : 'metric';
            document.getElementById('current-unit').textContent =
                unitSystem === 'metric' ? 'Metric (m)' : 'Imperial (ft)';

            // Update any displayed information
            if (selectedObject) {
                showObjectInfo(selectedObject);
            }
        });

        // Setup display settings toggles
        document.getElementById('show-labels').addEventListener('change', function() {
            showLabels = this.checked;
            updateRoomLabels();
        });

        document.getElementById('show-floor-plans').addEventListener('change', function() {
            showFloorPlans = this.checked;
            renderBlueprint();
        });

        // Set up floor navigation controls
        document.getElementById('floor-up').addEventListener('click', function() {
            changeFloor(1);
        });

        document.getElementById('floor-down').addEventListener('click', function() {
            changeFloor(-1);
        });

        // Main rendering function
        renderBlueprint();

        // Setup floor control buttons
        function setupFloorControls() {
            const floorControls = document.getElementById('floor-controls');

            // Clear existing buttons
            while (floorControls.childNodes.length > 1) {
                floorControls.removeChild(floorControls.lastChild);
            }

            // If no floor data is explicitly available, try to derive from rooms
            if (!availableFloors || availableFloors.length === 0) {
                document.getElementById('floor-controls').style.display = 'none';
                document.getElementById('floor-navigation').style.display = 'none';
                return;
            }

            // Add "All Floors" button
            const allFloorsBtn = document.createElement('button');
            allFloorsBtn.textContent = 'All Floors';
            allFloorsBtn.className = currentFloor === 'all' ? 'active' : '';
            allFloorsBtn.onclick = () => {
                setCurrentFloor('all');
                setActiveButton(allFloorsBtn);
            };
            floorControls.appendChild(allFloorsBtn);

            // Add individual floor buttons
            availableFloors.forEach(floorNum => {
                const btn = document.createElement('button');
                btn.textContent = getFloorName(floorNum);
                btn.dataset.floor = floorNum; // Store floor number as data attribute
                btn.className = currentFloor === floorNum ? 'active' : '';
                btn.onclick = () => {
                    setCurrentFloor(Number(floorNum)); // Convert to number to ensure type consistency
                    setActiveButton(btn);
                };
                floorControls.appendChild(btn);
            });
        }

        function getFloorName(floorNum) {
            if (floorNum === 0) return 'Ground';
            if (floorNum === 1) return '1st';
            if (floorNum === 2) return '2nd';
            if (floorNum === 3) return '3rd';
            if (floorNum > 3) return `${floorNum}th`;
            if (floorNum === -1) return 'Basement';
            if (floorNum < -1) return `B${Math.abs(floorNum)}`;
            return `Floor ${floorNum}`;
        }

        function setActiveButton(activeBtn) {
            const buttons = document.querySelectorAll('#floor-controls button');
            buttons.forEach(btn => {
                btn.className = (btn === activeBtn) ? 'active' : '';
            });
        }

        function changeFloor(direction) {
            if (availableFloors.length === 0) return;

            // Handle 'all' case
            if (currentFloor === 'all') {
                // When going from 'all' to a specific floor, choose either first or last floor based on direction
                currentFloor = direction > 0 ? availableFloors[0] : availableFloors[availableFloors.length - 1];
                setCurrentFloor(currentFloor);
                return;
            }

            // Find current index
            const currentIndex = availableFloors.indexOf(Number(currentFloor));
            if (currentIndex === -1) {
                // If current floor not found, default to first floor
                setCurrentFloor(availableFloors[0]);
                return;
            }

            // Calculate new index with bounds check
            let newIndex = currentIndex + direction;
            if (newIndex < 0) newIndex = 0;
            if (newIndex >= availableFloors.length) newIndex = availableFloors.length - 1;

            // Set new floor
            setCurrentFloor(availableFloors[newIndex]);
        }

        function setCurrentFloor(floor) {
            currentFloor = floor;
            updateFloorDisplay();
            renderBlueprint();

            // Also update the active button in the floor controls
            const buttons = document.querySelectorAll('#floor-controls button');
            buttons.forEach(btn => {
                if (floor === 'all' && btn.textContent === 'All Floors') {
                    btn.className = 'active';
                } else if (btn.dataset.floor !== undefined && Number(btn.dataset.floor) === Number(floor)) {
                    btn.className = 'active';
                } else {
                    btn.className = '';
                }
            });
        }

        function updateFloorDisplay() {
            const floorDisplay = document.getElementById('current-floor-display');
            if (floorDisplay) {
                if (currentFloor === 'all') {
                    floorDisplay.textContent = 'All Floors';
                } else {
                    floorDisplay.textContent = getFloorName(currentFloor);
                }
            }
        }

        // Helper function to get material for rooms
        function getRoomMaterial(roomData) {
            return new THREE.MeshPhongMaterial({
                color: COLORS.ROOM,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
        }

        // Helper function to get material for walls
        function getWallMaterial() {
            return new THREE.MeshPhongMaterial({
                color: COLORS.WALL,
                transparent: false,
                opacity: 1.0,
                side: THREE.DoubleSide
            });
        }

        // Helper function to get material for objects
        function getObjectMaterial(objectType) {
            const color = COLORS.OBJECT[objectType] || COLORS.OBJECT.default;
            return new THREE.MeshPhongMaterial({
                color: color,
                transparent: false,
                opacity: 1.0,
                side: THREE.DoubleSide
            });
        }

        // Clear all rendered elements
        function clearScene() {
            // Clear rooms
            meshes.rooms.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            meshes.rooms = [];

            // Clear walls
            meshes.walls.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            meshes.walls = [];

            // Clear objects
            meshes.objects.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            meshes.objects = [];

            // Clear labels
            meshes.labels.forEach(label => {
                scene.remove(label);
            });
            meshes.labels = [];
        }

        // Render the entire blueprint based on current floor selection
        function renderBlueprint() {
            clearScene();

            if (!blueprintData || !blueprintData.rooms || blueprintData.rooms.length === 0) {
                console.warn("No blueprint data to render");
                return;
            }

            // Filter rooms by current floor if specified
            const roomsToRender = blueprintData.rooms.filter(room => {
                if (currentFloor === 'all') return true;
                // Convert both to numbers for comparison to avoid type mismatches
                return Number(room.floor) === Number(currentFloor);
            });

            // Render rooms
            renderRooms(roomsToRender);

            // Render walls for those rooms
            if (blueprintData.walls) {
                // For "all floors" view or specific floor view, show walls appropriately
                const wallsToRender = currentFloor === 'all' ?
                    blueprintData.walls :
                    blueprintData.walls.filter(wall => {
                        if (wall.floor !== undefined) {
                            return Number(wall.floor) === Number(currentFloor);
                        }
                        // For walls without floor info, try to match them to rooms on the current floor
                        // This is a heuristic approach
                        return true;
                    });

                renderWalls(wallsToRender);
            }

            // Render objects (furniture) for those rooms
            if (blueprintData.objects) {
                const objectsToRender = currentFloor === 'all' ?
                    blueprintData.objects :
                    blueprintData.objects.filter(obj => {
                        // Find the room for this object
                        const room = blueprintData.rooms.find(room => room.id === obj.room_id);
                        return room && Number(room.floor) === Number(currentFloor);
                    });

                renderObjects(objectsToRender);
            }

            // Add room labels
            if (showLabels) {
                addRoomLabels(roomsToRender);
            }
        }

        // Create and add room labels
        function addRoomLabels(rooms) {
            // Remove previous labels
            meshes.labels.forEach(label => {
                scene.remove(label);
            });
            meshes.labels = [];

            // Skip if labels are disabled
            if (!showLabels) return;

            rooms.forEach(room => {
                if (!room.name || !room.center) return;

                // Get room center
                const center = room.center;

                // Create text sprite for the label
                const labelHeight = room.dimensions?.height || 2.5;
                createTextLabel(room.name, center.x, labelHeight + 0.3, center.y, room);
            });
        }

        // Update visibility of room labels
        function updateRoomLabels() {
            // Show/hide existing labels
            meshes.labels.forEach(label => {
                label.visible = showLabels;
            });

            // If labels are now visible but none exist, add them
            if (showLabels && meshes.labels.length === 0) {
                const roomsToRender = blueprintData.rooms.filter(room => {
                    if (currentFloor === 'all') return true;
                    return Number(room.floor) === Number(currentFloor);
                });
                addRoomLabels(roomsToRender);
            }
        }

        // Create a text label sprite
        function createTextLabel(text, x, y, z, userData) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;

            // Draw background
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Draw text
            context.font = 'Bold 24px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width/2, canvas.height/2);

            // Create sprite texture
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });

            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(2, 1, 1); // Adjust scale to make text readable

            // Store the room data for interaction
            sprite.userData = { type: 'label', data: userData };

            scene.add(sprite);
            meshes.labels.push(sprite);

            return sprite;
        }

        // Render rooms as 3D boxes
        function renderRooms(rooms) {
            rooms.forEach(room => {
                if (!room.dimensions || !room.bounds) {
                    console.warn("Room missing dimensions or bounds:", room);
                    return;
                }

                const width = room.dimensions.width;
                const height = room.dimensions.height || 2.5;
                const length = room.dimensions.length;
                const floor = Number(room.floor || 0); // Convert to number for consistent comparisons

                // Create exterior (transparent) and floor/ceiling (solid)
                const mainGeometry = new THREE.BoxGeometry(width, height, length);
                const mainMaterial = getRoomMaterial(room);

                const floorGeometry = new THREE.BoxGeometry(width, 0.05, length);
                const floorMaterial = new THREE.MeshPhongMaterial({
                    color: COLORS.FLOOR,
                    transparent: false,
                    opacity: 1.0
                });

                const ceilingGeometry = new THREE.BoxGeometry(width, 0.05, length);
                const ceilingMaterial = new THREE.MeshPhongMaterial({
                    color: COLORS.CEILING,
                    transparent: false,
                    opacity: 1.0
                });

                // Create the meshes
                const roomMesh = new THREE.Mesh(mainGeometry, mainMaterial);
                const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                const ceilingMesh = new THREE.Mesh(ceilingGeometry, ceilingMaterial);

                // Store room data on the mesh for selection
                roomMesh.userData = { type: 'room', data: room };

                // Position at the room's center
                // Calculate center from bounds
                const centerX = (room.bounds.min.x + room.bounds.max.x) / 2;
                const centerY = (room.bounds.min.y + room.bounds.max.y) / 2;

                // Calculate Y position based on floor number
                const floorHeight = 3.0; // Height between floors in meters
                const yOffset = floor * floorHeight;

                roomMesh.position.set(centerX, height/2 + yOffset, centerY);
                floorMesh.position.set(centerX, 0 + yOffset, centerY);
                ceilingMesh.position.set(centerX, height + yOffset, centerY);

                scene.add(roomMesh);
                scene.add(floorMesh);
                scene.add(ceilingMesh);

                meshes.rooms.push(roomMesh);
                meshes.rooms.push(floorMesh);
                meshes.rooms.push(ceilingMesh);
            });
        }

        // Render walls
        function renderWalls(walls) {
            walls.forEach(wall => {
                const start = wall.start;
                const end = wall.end;
                const height = wall.height || 2.5;
                const thickness = wall.thickness || 0.15;

                // Calculate wall length and orientation
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const length = Math.sqrt(dx * dx + dy * dy);

                // Create wall geometry with proper thickness
                const wallGeometry = new THREE.BoxGeometry(length, height, thickness);
                const wallMaterial = getWallMaterial();
                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);

                // Store wall data on the mesh for selection
                wallMesh.userData = { type: 'wall', data: wall };

                // Calculate midpoint and rotation
                const midpointX = (start.x + end.x) / 2;
                const midpointY = (start.y + end.y) / 2;

                // Rotation angle
                const angle = Math.atan2(dy, dx);

                // Check if wall belongs to a specific floor
                let yOffset = 0;
                if (wall.floor !== undefined) {
                    const floorHeight = 3.0; // Height between floors in meters
                    yOffset = Number(wall.floor) * floorHeight;
                }

                // Position the wall
                wallMesh.position.set(midpointX, height / 2 + yOffset, midpointY);
                wallMesh.rotation.y = -angle;

                scene.add(wallMesh);
                meshes.walls.push(wallMesh);
            });
        }

        // Render furniture/objects
        function renderObjects(objects) {
            objects.forEach(obj => {
                if (!obj.dimensions || !obj.position) {
                    console.warn("Object missing dimensions or position:", obj);
                    return;
                }

                const width = obj.dimensions.width;
                const height = obj.dimensions.height;
                const length = obj.dimensions.depth || obj.dimensions.length;

                // Find the room this object belongs to
                const room = blueprintData.rooms.find(r => r.id === obj.room_id);
                let yOffset = 0;
                if (room && room.floor !== undefined) {
                    const floorHeight = 3.0; // Height between floors in meters
                    yOffset = Number(room.floor) * floorHeight;
                }

                // Create object based on type
                let objectGeometry;

                // Special shapes for different furniture types
                switch(obj.type) {
                    case 'toilet':
                        objectGeometry = new THREE.CylinderGeometry(width/3, width/2.5, height, 12);
                        break;
                    case 'shower':
                        objectGeometry = new THREE.BoxGeometry(width, height, length);
                        break;
                    case 'bathtub':
                        objectGeometry = new THREE.BoxGeometry(width, height, length);
                        // Round the corners slightly
                        objectGeometry.translate(0, height/4, 0);
                        break;
                    case 'sofa':
                    case 'bed':
                    case 'king_bed':
                        objectGeometry = new THREE.BoxGeometry(width, height, length);
                        // Add a little elevation
                        objectGeometry.translate(0, height/2, 0);
                        break;
                    default:
                        // Default box shape for most objects
                        objectGeometry = new THREE.BoxGeometry(width, height, length);
                        break;
                }

                const objectMaterial = getObjectMaterial(obj.type);
                const objectMesh = new THREE.Mesh(objectGeometry, objectMaterial);

                // Store object data on the mesh for selection
                objectMesh.userData = { type: 'object', data: obj };

                // Position at the object's position
                const x = obj.position.x;
                const y = (obj.position.z || height/2) + yOffset;
                const z = obj.position.y;

                objectMesh.position.set(x, y, z);

                // Apply rotation if specified
                if (obj.rotation) {
                    objectMesh.rotation.y = obj.rotation * Math.PI / 180;
                }

                scene.add(objectMesh);
                meshes.objects.push(objectMesh);
            });
        }

        // Handle object selection with raycaster
        document.addEventListener('click', onDocumentClick, false);

        function onDocumentClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects([...meshes.rooms, ...meshes.walls, ...meshes.objects, ...meshes.labels]);

            // Reset previous selection
            if (selectedObject) {
                if (selectedObject.userData.type === 'object') {
                    selectedObject.material.color.setHex(
                        COLORS.OBJECT[selectedObject.userData.data.type] || COLORS.OBJECT.default
                    );
                } else if (selectedObject.userData.type === 'room') {
                    selectedObject.material.color.setHex(COLORS.ROOM);
                } else if (selectedObject.userData.type === 'wall') {
                    selectedObject.material.color.setHex(COLORS.WALL);
                }
                document.getElementById('object-info').style.display = 'none';
            }

            selectedObject = null;

            // Process new selection
            if (intersects.length > 0) {
                selectedObject = intersects[0].object;

                // Check if we clicked on a label
                if (selectedObject.userData.type === 'label') {
                    // Find the actual room object instead
                    const roomData = selectedObject.userData.data;
                    const roomMesh = meshes.rooms.find(mesh =>
                        mesh.userData.type === 'room' && mesh.userData.data.id === roomData.id);

                    if (roomMesh) {
                        selectedObject = roomMesh;
                    }
                }

                // Highlight selected object
                if (selectedObject.userData.type === 'object' ||
                    selectedObject.userData.type === 'room' ||
                    selectedObject.userData.type === 'wall') {

                    selectedObject.material.color.setHex(COLORS.SELECTED);

                    // Show info about selected object
                    showObjectInfo(selectedObject);
                }
            }
        }

        function showObjectInfo(object) {
            const infoPanel = document.getElementById('object-info');
            const data = object.userData.data;
            let html = '';

            if (object.userData.type === 'room') {
                html = `
                    <h3>Room: ${data.name || data.id}</h3>
                    <p>Type: ${data.type || 'Standard'}</p>
                    <p>Floor: ${data.floor || 'Ground'}</p>
                    <p>Dimensions: ${formatDistance(data.dimensions.width)} √ó
                                  ${formatDistance(data.dimensions.length)} √ó
                                  ${formatDistance(data.dimensions.height)}</p>
                    <p>Area: ${formatArea(data.dimensions.width * data.dimensions.length)}</p>
                `;
            } else if (object.userData.type === 'object') {
                html = `
                    <h3>Object: ${data.type.replace('_', ' ')}</h3>
                    <p>Room: ${data.room_id}</p>
                    <p>Size: ${formatDistance(data.dimensions.width)} √ó
                              ${formatDistance(data.dimensions.depth || data.dimensions.length)} √ó
                              ${formatDistance(data.dimensions.height)}</p>
                    <p>Position: (${formatDistance(data.position.x)},
                                 ${formatDistance(data.position.y)},
                                 ${formatDistance(data.position.z || 0)})</p>
                `;
            } else if (object.userData.type === 'wall') {
                html = `
                    <h3>Wall</h3>
                    <p>ID: ${data.id}</p>
                    <p>Height: ${formatDistance(data.height || 2.5)}</p>
                    <p>Thickness: ${formatDistance(data.thickness || 0.15)}</p>
                    <p>Length: ${formatDistance(calculateDistance(data.start, data.end))}</p>
                `;
            }

            infoPanel.innerHTML = html;
            infoPanel.style.display = 'block';
        }

        function calculateDistance(point1, point2) {
            const dx = point2.x - point1.x;
            const dy = point2.y - point1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);

            // Update label positions to face camera
            meshes.labels.forEach(label => {
                label.quaternion.copy(camera.quaternion);
            });
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function showError(message) {
            console.error(message);
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
    </script>
</body>
</html>